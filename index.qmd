---
title: "CER &middot; BEANS: Community Engaged Research Balanced Expressions and Assessments with Nuanced Scores"
subtitle: "A Framework for Constructing Quantitative Metrics for Community Engaged Research Projects"
author:
  - name: Jeremy F Price 
    url: https://www.jeremyfprice.info/
    affiliation: IU School of Education-Indianapolis
    affiliation_url: https://education.iupui.edu/
    orcid: 0000-0002-6506-3526
license: "CC BY-SA"
mainfont: domine
sansfont: rubik
monofont: "JetBrains Mono"
highlight-style: a11y
code-overflow: wrap
reference-location: margin
cap-location: margin
link-external-icon: false
link-external-newwindow: true
repo-url: https://github.com/jeremyfprice/cer-beans
citation:
  type: document
  issued: 2023
  url: https://github.com/jeremyfprice/cer-beans
google-scholar: true
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

```{r load-libraries, message = FALSE, warning=FALSE, echo = FALSE}
library(scales)
library(gt)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggpubr)
library(ggthemes)
library(glue)
library(ggrepel)
library(ggtext)
library(showtext)
library(ggforce)
```

```{r load-fonts, echo = FALSE, include=FALSE}
font_add_google("Rubik", "rubik", regular.wt = 700)
font_add_google("JetBrains Mono", "jetbrains", regular.wt = 700)
font_add_google("Domine", "domine", regular.wt = 700)
```

```{r setup, echo=FALSE}
category_scores <- data.frame(
  project_name = character(),
  category_name = character(),
  category_impact_number = integer(),
  category_index = double(),
  category_score = integer()
)

iu_palette <<- c(
  "#990000",
  "#FFAA00",
  "#006298",
  "#7D4C73",
  "#056E41"
)

spiral_palette <<- c(
  "1" = "#990000",
  "2" = "#F23A3F",
  "3" = "#FFD6DB",
  "4" = "#FFF7F8"
)

category_levels <<- c(
  "Participation",
  "Engagement",
  "Infrastructure",
  "Outputs",
  "Sustainability"
)

raw_impacts <<- c(
  "Participants",
  "Hours",
  "Infrastructures",
  "Outputs",
  "Partners"
)

credit_frame <- data.frame(
  x = 1,
  y = 1,
  label = glue("Community Engaged Research Balanced Expressions and Assessments with Nuanced Scores -- Generated {Sys.Date()} -- CC BY-NC-SA 4.0")
)
credit_line <<- ggplot(
  credit_frame,
  aes(
    x = x,
    y = y,
    label = label
  )
) +
  geom_richtext(
    fill = NA,
    label.color = NA,
    color = "#191919",
    size = 2.5
  ) +
  theme_light() +
  theme(
    legend.position = "none",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.border = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent", color = NA)
  )

lambda_ripple <<- 0.55

# Source and inspiration: https://datasketch.dev/post/2020-08-09-how-to-make-spirals-with-r/
# vogel_t <- 1:100
# vogel_r <- sqrt(vogel_t)
# golden_angle <- pi * (3 - sqrt(5))
# theta <- vogel_t * golden_angle
# vogel_x <- vogel_r * cos(theta)
# vogel_y <- vogel_r * sin(theta)
# vogel_coords <<- tibble::tibble(vogel_x, vogel_y)
# Archimedan
# n_arch <- 100
# # b separation of turns
# t_arch <- seq(0, 3  * 2 * pi, length.out = n_arch)
# x_arch <- (0 + 1 * t_arch) * cos(t_arch)
# y_arch <- (0 + 1 * t_arch) * sin(t_arch)
# arch_coords <- tibble::tibble(x_arch, y_arch)
# arch_coords$n <- 1:n
```

```{r define-functions, echo=FALSE}
add_category <- function(the_frame,
                         the_project,
                         category_name,
                         impact_number,
                         component_weight,
                         component_score_1,
                         component_score_2) {
  temp_frame <- data.frame(
    project_name = character(),
    category_name = character(),
    category_impact_number = integer(),
    category_index = double(),
    category_score = integer()
  )
  temp_frame <- temp_frame |>
    add_row(
      project_name = the_project,
      category_name = category_name,
      category_impact_number = impact_number,
      category_index = round(
        ((component_score_1 + component_score_2) / 2),
        digits = 2
      ),
      category_score = round(
        (component_weight * (category_impact_number * (1 + category_index))),
        digits = 0
      )
    )
  the_frame <- rbind(the_frame, temp_frame)
  temp_frame <- NULL
  return(the_frame)
}

create_display_table <- function(the_frame,
                                 the_category,
                                 component_score_1,
                                 component_score_2,
                                 component_title_list) {
  the_table <- the_frame |>
    filter(category_name == the_category) |>
    pivot_longer(
      cols = c(
        "category_impact_number",
        "category_index",
        "category_score"
      ),
      names_to = "Component",
      values_to = "Value"
    ) |>
    select(-category_name) |>
    add_row(
      Component = "Component 1",
      Value = component_score_1,
      .after = 1
    ) |>
    add_row(
      Component = "Component 2",
      Value = component_score_2,
      .after = 2
    )
  the_table$Component <- component_title_list
  return(the_table)
}

adjust_component_score <- function(the_score, the_coefficient) {
  the_component_score <- round(the_score * the_coefficient, 2)
}

bake_donut <- function(category_scores, the_project, the_overall) {
  the_frame <- category_scores |>
    filter(project_name == the_project)
  donut_labels <- vector()
  for (i in 1:5) {
    donut_labels[i] <- glue(
      "{the_frame$category_name[i]}\n{the_frame$category_index[i]}"
    )
  }
  donut_frame <- data.frame(
    names = category_levels,
    label = donut_labels,
    score = the_frame$category_index
  )
  donut_frame$names <- factor(
    donut_frame$names,
    levels = category_levels
  )
  bean_donut <- ggdonutchart(
    donut_frame, "score",
    fill = "names", color = "#EDEBEB",
    palette = iu_palette,
    lab.font = "#191919",
    # font.family = "rubik"
  ) +
    annotate(
      geom = "text",
      x = 0.5,
      y = 0,
      label = the_overall,
      size = 18,
      # family = "jetbrains"
    ) +
    theme(
      legend.position = "none",
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent", color = NA),
      axis.ticks = element_blank()
    )
  return(bean_donut)
}

prep_raw <- function(category_scores, the_project) {
  the.frame <- category_scores |>
    filter(project_name == the_project)
  raw_labels <- vector()

  for (i in 1:5) {
    raw_labels[i] <- glue(
      "{category_scores$category_impact_number[i]} {raw_impacts[i]}"
    )
  }

  raw_frame <- data.frame(
    names = category_levels,
    label = raw_labels,
    values = the.frame$category_impact_number,
    bean = c("BEAN", "BEAN", "BEAN", "BEAN", "BEAN")
  )

  raw_frame$names <- factor(
    raw_frame$names,
    levels = rev(category_levels)
  )

  raw_frame$values_adjusted <- rescale(raw_frame$values, to = c(3, 100))

  raw_bar <- ggplot(raw_frame, aes(x = bean, y = values_adjusted, fill = names)) +
    geom_bar(
      stat = "identity",
      width = 1,
      color = "#EDEBEB"
    ) +
    coord_flip() +
    scale_fill_manual(values = rev(iu_palette)) +
    theme_light() +
    theme(
      legend.position = "none",
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.border = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent", color = NA)
    )
  return(raw_bar)
}

prep_labels <- function(category_scores, the_project) {
  the_frame <- category_scores |>
    filter(project_name == the_project)
  label_frame <- data.frame(
    x = 1,
    y = 2,
    label = glue(
      "<span style='color:#99000088;'>█</span> <span style='color:#990000;'><b>{the_frame$category_impact_number[1]}</b></span> Participants <span style='color:#FFAA0088;'>█</span> <span style='color:#FFAA00;'><b>{the_frame$category_impact_number[2]}</b></span> Engagement Hours <span style='color:#00629888;'>█</span> <span style='color:#006298;'><b>{the_frame$category_impact_number[3]}</b></span> Infrastructure Products <span style='color:#59264D88;'>█</span> <span style='color:#59264D;'><b>{the_frame$category_impact_number[4]}</b></span> Outputs <span style='color:#056E4188;'>█</span> <span style='color:#056E41;'><b>{the_frame$category_impact_number[5]}</b></span> Partners"
    )
  )

  label_line <- ggplot(
    label_frame,
    aes(
      x = x,
      y = y,
      label = label
    )
  ) +
    geom_richtext(
      fill = NA,
      label.color = NA,
      color = "#191919",
      size = 3.5
    ) +
    theme_light() +
    theme(
      legend.position = "none",
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.border = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "transparent", color = NA)
    )
  return(label_line)
}

calculate_overall <- function(category_scores, the_project) {
  overall_score <- category_scores |>
    filter(project_name == the_project) |>
    tally(category_score) |>
    pull(n)
}

compile_badge <- function(the_donut, the_raw, the_labels, project_abbrev) {
  the_file <- glue("outputs/{project_abbrev}_badge.png")
  detailed_badge <- ggarrange(
    the_donut,
    the_raw,
    the_labels,
    credit_line,
    ncol = 1,
    nrow = 4,
    heights = c(8, 1, 1, 1)
  )
  ggsave(
    detailed_badge,
    filename = the_file,
    dpi = 320,
    width = 8,
    height = 8,
    units = "in"
  )
}

map_ripples <- function(the_project, the_frame) {
  the_project <- "PD @ TG"
  the_frame <- pdtg_ripple

  the_frame <- the_frame |>
    filter(project_name == the_project) |>
    select(-project_name)
  library(DiagrammeR)
  the_graph <- the_frame |>
    graph_from_data_frame(directed = TRUE)
}

map_spiral <- function(the_frame, the_colors, the_levels, the_grid) {
  the_frame <- the_frame |>
    mutate(values = ((values / sum(values)) * 100))
  the_frame$values <- round(the_frame$values, digits = 0)
  rep_frame <- rep(the_frame$name, times = the_frame$values)
  spiral_frame <- data.frame(
    group = rep_frame,
    x = vogel_coords$vogel_x,
    y = vogel_coords$vogel_y
  )
  the_spiral <- ggplot(spiral_frame) +
    geom_segment(
      aes(
        x = -10,
        y = 0,
        xend = 10,
        yend = 0
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = -10,
        xend = 0,
        yend = 10
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 8,
        yend = -8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 8,
        yend = 8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -8,
        yend = -8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -8,
        yend = 8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 1
      ),
      color = "#eeeeee",
      fill = "#ffffff"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 5
      ),
      color = "#eeeeee"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 10
      ),
      color = "#eeeeeecc"
    ) +
    geom_point(
      aes(
        x = 0,
        y = 0
      ),
      color = "#eeeeee",
      size = 2
    ) +
    geom_point(
      aes(
        x,
        y,
        color = group
      ),
      size = 6
    ) +
    coord_equal() +
    scale_color_manual(
      values = the_colors
    ) +
    theme_minimal() +
    theme(
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      legend.title = element_blank(),
      legend.position = "bottom",
      panel.background = element_rect(
        fill = "transparent",
        color = NA
      ),
      plot.background = element_rect(
        fill = "transparent",
        color = NA
      )
    )
}

vogel_spiral <- function(n) {
  t <- 1:n
  r <- sqrt(t)
  golden_angle <- pi * (3 - sqrt(5))
  theta <- t * golden_angle
  x <- r * cos(theta)
  y <- r * sin(theta)
  d <- tibble::tibble(x, y)
  d$n <- 1:n
  d
}

archimedean_spiral <- function(n, a = 0, b = 1, turns = 3) {
  # b separation of turns
  t <- seq(0, turns * 2 * pi, length.out = n)
  x <- (a + b * t) * cos(t)
  y <- (a + b * t) * sin(t)
  d <- tibble::tibble(x, y)
  d$n <- 1:n
  d
}

calculate_ripple <- function(the_frame) {
  the_frame$ripple_score <- lambda_ripple *
    (the_frame$values /
      (log(the_frame$group + 1)))
  the_frame <- the_frame |>
    mutate(
      ripple_score = if_else(
        is.infinite(ripple_score),
        values,
        ripple_score
      )
    )
  the_frame$ripple_score <- round(
    the_frame$ripple_score,
    digits = 0
  )
  the_frame$adj_score <- ((the_frame$ripple_score /
    sum(the_frame$ripple_score)) *
    100)
  the_frame$adj_score <- round(
    the_frame$adj_score,
    digits = 0
  )
  the_frame <- the_frame |>
    mutate(
      group_name = glue(
        "{values} {group_name}\n(η = {ripple_score})"
      )
    ) |>
    mutate(group = group + 1)
}

prepare_vogel <- function(the_frame) {
  rep_frame <- data.frame(
    group = rep(
      the_frame$group,
      times = the_frame$adj_score
    ),
    group_name = rep(
      the_frame$group_name,
      the_frame$adj_score
    )
  )
  spiral_frame <- vogel_spiral(sum(the_frame$adj_score))
  spiral_frame$group_name <- rep_frame$group_name
  spiral_frame$group <- rep_frame$group
  return(spiral_frame)
}

plot_vogel <- function(the_frame, the_labels) {
  the_frame$group <- factor(
    the_frame$group,
    levels = c(1:max(the_frame$group))
  )
  vogel_plot <- ggplot(the_frame) +
    geom_segment(
      aes(
        x = -10,
        y = 0,
        xend = 10,
        yend = 0
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = -10,
        xend = 0,
        yend = 10
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 8,
        yend = -8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 8,
        yend = 8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -8,
        yend = -8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -8,
        yend = 8
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 1
      ),
      color = "#eeeeee",
      fill = "#ffffff"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 5
      ),
      color = "#eeeeee"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 10
      ),
      color = "#eeeeee"
    ) +
    geom_point(
      aes(
        x = 0,
        y = 0
      ),
      color = "#eeeeee",
      size = 2
    ) +
    geom_point(
      aes(
        x,
        y,
        color = group
      ),
      size = 6
    ) +
    coord_equal() +
    scale_color_manual(
      labels = the_labels,
      values = spiral_palette
    ) +
    theme_minimal() +
    theme(
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      legend.title = element_blank(),
      legend.position = "bottom",
      panel.background = element_rect(
        fill = "transparent",
        color = NA
      ),
      plot.background = element_rect(
        fill = "transparent",
        color = NA
      )
    )
}

prep_composite <- function(the_frame, the_project) {
  composite_frame <- the_frame |>
    filter(project_name == the_project) |>
    mutate(category_name = glue("{category_name}\n(i = {category_index}, s = {category_score})")) |>
    mutate(category_score = category_score + 1)
  composite_frame$category <- c(1, 2, 3, 4, 5)
  composite_frame <- composite_frame |>
    mutate(adj_score = ((category_score / sum(category_score)) * 100))
  composite_frame$adj_score <- round(composite_frame$adj_score, digits = 0)
  return(composite_frame)
}

prep_arch <- function(the_frame) {
  arch_frame <- archimedean_spiral(sum(the_frame$adj_score))
  arch_frame$category_name <- rep(
    the_frame$category_name,
    times = the_frame$adj_score
  )
  arch_frame$category <- rep(
    the_frame$category,
    times = the_frame$adj_score
  )
  return(arch_frame)
}

plot_arch <- function(arch_frame, the_frame) {
  arch_frame$category <- factor(
    arch_frame$category,
    levels = c("1", "2", "3", "4", "5")
  )
  the_arch <- ggplot(arch_frame) +
    geom_segment(
      aes(
        x = -16,
        y = 0,
        xend = 16,
        yend = 0
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = -16,
        xend = 0,
        yend = 16
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 15,
        yend = -15
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = 15,
        yend = 15
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -15,
        yend = -15
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_segment(
      aes(
        x = 0,
        y = 0,
        xend = -15,
        yend = 15
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.01
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 1
      ),
      color = "#eeeeee",
      fill = "#ffffff"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 5
      ),
      color = "#eeeeee"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 10
      ),
      color = "#eeeeeecc"
    ) +
    geom_circle(
      aes(
        x0 = 0,
        y0 = 0,
        r = 15
      ),
      color = "#eeeeeecc"
    ) +
    geom_point(aes(x, y, color = category), size = 8) +
    coord_equal() +
    scale_color_manual(
      values = iu_palette,
      labels = the_frame$category_name
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      legend.title = element_blank(),
      panel.background = element_rect(
        fill = "transparent",
        color = NA
      ),
      plot.background = element_rect(
        fill = "transparent",
        color = NA
      )
    ) +
    guides(color = guide_legend(nrow = 1, byrow = TRUE))
  return(the_arch)
}

create_title_line <- function(title_description, title_score) {
  the_title <- data.frame(
    x = 1,
    y = 1,
    label = glue("{title_description} <b>{title_score}</b>")
  )
  title_line <<- ggplot(
    the_title,
    aes(
      x = x,
      y = y,
      label = label
    )
  ) +
    geom_richtext(
      fill = NA,
      label.color = NA,
      color = "#EDEBEB",
      size = 9
    ) +
    theme_light() +
    theme(
      legend.position = "none",
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.border = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "transparent"),
      plot.background = element_rect(fill = "#990000aa", color = "#990000aa")
    )
  return(title_line)
}

calculate_indicator_score <- function(the_frame, the_project, indicator_weights) {
  composite_indicator_score <- the_frame |>
    filter(project_name == the_project)
  composite_indicator_score <- cbind(composite_indicator_score, indicator_weights)
  composite_indicator_score <- composite_indicator_score |>
    mutate(adj_indicator = category_impact_number * weights) |>
    tally(adj_indicator) |>
    pull(n)
  composite_indicator_score <- round(
    composite_indicator_score,
    digits = 0
  )
}

construct_bottom_badge <- function(arch_title, ripple_title, composite_arch, vogel_ripple) {
  bottom_badge <- ggarrange(
    arch_title,
    NULL,
    ripple_title,
    composite_arch,
    NULL,
    vogel_ripple,
    ncol = 3,
    nrow = 2,
    widths = c(14.5, 2, 14.5),
    heights = c(2, 14.5)
  )
  return(bottom_badge)
}

prep_indicators <- function(the_frame, the_project) {
  indicator_frame <- the_frame |>
    filter(project_name == the_project) |>
    select(category_name, category_impact_number)
  indicator_frame$x <- c(1, 2, 3, 4, 5)
  indicator_frame$y <- 1
  indicator_frame$category_name <- factor(
    indicator_frame$category_name,
    levels = category_levels
  )
  correct_infrastructure <- if_else(
    indicator_frame$category_impact_number[3] == 1,
    "Infrastructure Product",
    "Infrastructure Products"
  )
  correct_output <- if_else(
    indicator_frame$category_impact_number[4] == 1,
    "Output",
    "Outputs"
  )
  correct_partner <- if_else(
    indicator_frame$category_impact_number[5] == 1,
    "Partner",
    "Partners"
  )
  indicator_frame$category_labels <- c(
    glue("{indicator_frame$category_impact_number[1]} Participants"),
    glue("{indicator_frame$category_impact_number[2]} Engagement Hours"),
    glue("{indicator_frame$category_impact_number[3]} {correct_infrastructure}"),
    glue("{indicator_frame$category_impact_number[4]} {correct_output}"),
    glue("{indicator_frame$category_impact_number[5]} {correct_partner}")
  )
  return(indicator_frame)
}

plot_indicators <- function(indicator_frame) {
  if (0 %in% indicator_frame$category_impact_number) {
    min_scale <- 0.01
  } else {
    min_scale <- ((min(indicator_frame$category_impact_number) /
      sum(indicator_frame$category_impact_number)) * 60) + 5
  }
  indicator_bubbles <- ggplot(indicator_frame) +
    geom_segment(
      aes(
        x = 0,
        y = 1,
        xend = 6,
        yend = 1
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_segment(
      aes(
        x = 1,
        y = -0.75,
        xend = 1,
        yend = 2.75
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_segment(
      aes(
        x = 3,
        y = -0.75,
        xend = 3,
        yend = 2.75
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_segment(
      aes(
        x = 2,
        y = -0.75,
        xend = 2,
        yend = 2.75
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_segment(
      aes(
        x = 4,
        y = -0.75,
        xend = 4,
        yend = 2.75
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_segment(
      aes(
        x = 5,
        y = -0.75,
        xend = 5,
        yend = 2.75
      ),
      color = "#eeeeee",
      linetype = "solid",
      linewidth = 0.5
    ) +
    geom_point(
      aes(
        x = 1,
        y = 1
      ),
      shape = 21, color = "#eeeeee", fill = "transparent", size = 60, stroke = 0.5
    ) +
    geom_point(
      aes(
        x = 2,
        y = 1
      ),
      shape = 21, color = "#eeeeee", fill = "transparent", size = 60, stroke = 0.5
    ) +
    geom_point(
      aes(
        x = 3,
        y = 1
      ),
      shape = 21, color = "#eeeeee", fill = "transparent", size = 60, stroke = 0.5
    ) +
    geom_point(
      aes(
        x = 4,
        y = 1
      ),
      shape = 21, color = "#eeeeee", fill = "transparent", size = 60, stroke = 0.5
    ) +
    geom_point(
      aes(
        x = 5,
        y = 1
      ),
      shape = 21, color = "#eeeeee", fill = "transparent", size = 60, stroke = 0.5
    ) +
    geom_point(aes(
      x = x,
      y = y,
      size = category_impact_number,
      color = category_name
    )) +
    xlim(0, 6) +
    ylim(-0.75, 2.75) +
    scale_color_manual(
      values = iu_palette,
      labels = indicator_frame$category_labels
    ) +
    scale_size(range = c(min_scale, 60)) +
    guides(
      fill = FALSE,
      size = FALSE
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      axis.ticks = element_blank(),
      axis.text = element_blank(),
      axis.title = element_blank(),
      panel.grid = element_blank(),
      legend.title = element_blank(),
      panel.background = element_rect(
        fill = "transparent",
        color = NA
      ),
      plot.background = element_rect(
        fill = "transparent",
        color = NA
      )
    )
  return(indicator_bubbles)
}

construct_badge <- function(indicator_title, indicator_plot, bottom_badge) {
  full_badge <- ggarrange(
    indicator_title,
    indicator_plot,
    bottom_badge,
    credit_line,
    ncol = 1,
    nrow = 4,
    heights = c(
      1.5,
      8,
      16,
      1
    )
  )
}
```

## Introduction

> "Every little bean must be heard as well as seen!"
>
> --- Erich Maria Remarque, <cite>All Quiet on the Western Front</cite>

![A hill of important beans just waiting to be counted as imagined by Adobe Firefly](assets/hillofbeans2.jpg)

Quantitative measures capture only a small piece of the (bean) pie, but people
in academia ❤️&nbsp;**love**&nbsp;❤️ putting numbers on things and counting them (beans).

Rather than sitting back and stewing like a pot of vegetarian chili while fretting
about whether or not faculty committees and administrators will count the kinds of
beans I hope they would count, I decided to create my own set of beans for them to
count.

Therefore:

**Community Engaged Research Balanced Expressions and Assessments with Nuanced Scores
(CER &middot; BEANS)**[CER &middot; BEANS is pronounced "Sir&nbsp;Beans."]{.aside}

I was inspired by the [Altmetric badge](https://www.altmetric.com/), so I want to
make sure to create a system of beans that is:

1. Easy to grok and nice to look at.[To [grok](https://www.britannica.com/topic/grok) something is to understand it intuitively and deeply.]{.aside}
2. Authentic and meaningful to the work and experiences of community engaged researchers.
3. Usable as a critical framing for the kind of work community engaged researchers
should be focusing on.
4. Translatable, transferable, robust, resilient, dynamic, and extensible.

How 'bout *these* beans?

![](outputs/fafi_badge.png)

Pretty [*radicle,*](https://en.wikipedia.org/wiki/Radicle) eh?

:::{.callout-note}

## If You Choose to Die on This Hill (of Beans)...

I am open to collaboration, dialogue, and disagreement. You can even
[open an issue](https://github.com/jeremyfprice/cer-beans/issues/new) if you'd
like to make it official. Contributions are welcomed, please read the 
[Code of Conduct](https://github.com/jeremyfprice/cer-beans/blob/main/CODE_OF_CONDUCT.md).
:::

## Identifying the Metrics

> "You never cook onions with your beans. That's a recipe for tear gas."
>
> --- Justin Swapp, <cite>The Shadow's Servant</cite>

![An image of medieval academics counting beans as imagined by Adobe Firefly](assets/beancounters3.jpg)

When evaluating community-engaged programs, it's important to consider various metrics that assess different aspects of the program's effectiveness and impact.

:::{.callout-warning}

## If You Had a Roomful of Awards that Didn't Mean Beans...

It is important to remember a number, a score, or even a collection or bean hill
of scores or numbers, *do not tell the whole story* of your community engaged research.
This framework is provided to *help you tell that story* using a system that is
easily recognizable and considered a valid form of evidence.

These numbers are a guidepost for your readers--or more likely--your evaluators.
:::

Now that I've provided the warning, remember that academics are first and foremost
makers of bean stalks[I make bean stalks, I'm<br />A builder, like yourself.<br />-- Edna St. Vincent Millay, [The Bean-Stalk](https://americanliterature.com/author/edna-st-vincent-millay/poem/the-bean-stalk)]{.aside}: we are trained to make cases and construct narratives.
Here are some tips for you to consider about what CER &middot; BEANS *does* provide for
you as you construct a narrative around your work:

::: {.callout-tip}

## Ways to Build Bean Stalks

* 🪞 **Reflection:** It provides an overall reflection on your work and where you have focused your energies. CER &middot; BEANS gives you an indication of the impact your work has had, allowing you to discuss your successes.

* 📸 **Snapshot:** It provides a snapshot of where you are in a longer process, what has worked well so far, and where you will be focusing your efforts in the near future.

* 🗺️ **Map:** It provides a rough map of where you and your collaborators, partners, and participants can take the work moving forward.

:::

CER &middot; BEANS focuses on *five categories* and they each
result in an `category score`. Each of the category scores contribute to the
`overall score`. These are the five categories:

1. Participants
2. Engagement
3. Infrastructures
4. Outputs
5. Sustainability

Each of the `category scores` ($S_C$) follow a predictable pattern, that includes an
`impact number` ($I_C$) that is amplified by a set of **category component ratings** ($R_C$,
individual ratings represented by $r_{C1} \ldots r_C$). This is the general formula
for a `category score`:

$$
S_C = W_C \cdot I_C \cdot \left(1 + \frac{\sum r_{C_1} \ldots r_{C_n}}{|R_C|}\right)
$$

The process for computing each of the `category scores` is essentially calculating the
average for the ratings in the category and then adding 1 to this average since
the ratings are between 0 and 1 and only numbers greater than 1 will amplify things.
The `amplifier score` is then multiplied by the `impact number`, which can be the
number of participants, contact hours, institutional partners, etc.

The categories contribute to the `overall score` ($S_O$) as a straight-forward
summation of all the category scores, where $s$ represents the `category scores`,
$x$ represents the set of categories, and $n$ is the number of categories:

$$
S_O = \sum_{C=1}^n s_C
$$

This `overall score` is  similar to the [Altmetric Attention Score](https://www.altmetric.com/about-us/our-data/donut-and-altmetric-attention-score/#:~:text=The%20Altmetric%20Attention%20Score%20is%20an%20automatically%20calculated,3%20main%20factors:) in that
it is a *weighted count*. The `overall score` increases 

Each of these categories and their components are described in some detail below. The
idea, the math, the concepts, are all licensed under a [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/) license[The code itself is licensed similarly under an [MIT License](https://github.com/jeremyfprice/cer-beans/blob/main/LICENSE).]{.aside}, so you are welcome to take these ideas and adapt them to your particular needs and preferences
(as long as you give credit where credit is due and share your adapted work alike).

## Participants Component Score

The Participants Component Score represents the people involved in the project.
Included in this score are the number of people involved, representation of marginalized
community members and identities, and representation of intersectional identities and
community membership.

```{r participants-weight, echo=TRUE}
participants_weight <- 1
```

```{r participants-frame, echo = FALSE}
participants_frame <- data.frame(
  marginalized_proportions = c(
    "No Marginalized Participants",
    "A Few Marginalized Participants",
    "Some Marginalized Participants",
    "Just Under Half Marginalized Participants",
    "About Half Marginalized Participants",
    "Just Over Half Marginalized Participants",
    "Mostly Marginalized Participants",
    "Predominantly Marginalized Participants",
    "Nearly All Marginalized Participants",
    "All Marginalized Participants"
  ),
  intersectionally_marginalized = c(
    "No Intersectionally Marginalized Participants",
    "A Few Intersectionally Marginalized Participants",
    "Some Intersectionally Marginalized Participants",
    "Just Under Half Intersectionally Marginalized Participants",
    "About Half Intersectionally Marginalized Participants",
    "Just Over Half Intersectionally Marginalized Participants",
    "Mostly Marginalized Intersectionally Participants",
    "Predominantly Intersectionally Marginalized Participants",
    "Nearly All Intersectionally Marginalized Participants",
    "All Marginalized Intersectionally Participants"
  ),
  participants_value = c(
    0.1,
    0.25,
    0.33,
    0.4,
    0.5,
    0.75,
    0.85,
    0.9,
    0.95,
    1
  )
)
gt(participants_frame)
```

### Number of Participants

How many participants involved? This is $p_n$.

For the Professional Development project at one of the elementary schools, there
were 70 directly teachers involved. For Family as Faculty as an Infrastructure,
the participants consisted of the following:

* 1 School Principal
* 2 Institutional Leaders
* 3 University Faculty and Staff (not part of the project team)
* 4 Neighborhood Participants
* 5 Family Leaders
* 5 Cooperating Teachers
* 30 Undergraduate Students

This is a total of 50 direct participants.

```{r, echo = TRUE, echo = TRUE}
tg_number_of_participants <- 70
fafi_number_of_participants <- 50
stst_number_of_participants <- 7
```

### Marginalized Proportions Score

What proportion of the participants represent and come from marginalized identities and
communities? This is $p_m$.

You can consider the direct population you are working with, *or* you can consider
your *target population* who may be one degree removed when deciding on the $p_m$
rating. If you consider your target, rather than direct, population, there is a 
"penalty" or damping for doing so in the form of a marginalized proportions coefficient,
$\beta_m$. If you are you working directly with the population, $\beta_m$ is 1,
or no damping If you are working with, for example, teachers or health care workers
who will work with your target population, then $\beta_m$ is 0.85 to dampen the
score.

For the Professional Development project, the students in the school--the actual
target population--predominantly represent marginalized identities and communities,
so $p_m$ is 0.9. The students are one degree away from the teachers, however,
so $\beta_m$ is 0.85 to dampen the component score. For Family as Faculty as an
Infrastructure, just over half of the participants represent marginalized identities
and communities, so $p_m$ is 0.75. We are considering this population directly
(we can consider ripple effects later on) so $\beta_m$ is set to 1 so there is
no damping of the score.

```{r, echo = TRUE, echo = TRUE}
stst_marginalized_proportions_value <- 1
stst_marginalized_proportions_coefficient <- 1
tg_marginalized_proportions_value <- 0.95
tg_marginalized_proportions_coefficient <- 0.85
fafi_marginalized_proportions_value <- 0.75
fafi_marginalized_proportions_coefficient <- 1
```

### Intersectionally Marginalized Proportions Score

What proportion of the participants represent and come from multiple and intersecting
marginalized identities and communities? This is $p_i$.

Just like with the Marginalized Proportions Score, you can consider the direct
population you are working with, or you can consider your target population. The
`Intersectionally Marginalized Coefficient`, $\beta_i$, is the same as above.
If you consider your target, rather than direct, population, $\beta_i$ is 0.85.
If you are you working directly with the population, $\beta_i$ is 1.

For the Professional Development project, we will again be considering the intersectionality
of the students in the school. Nearly all students represent marginalized identities
and communities, so $p_i$ is 0.9. The students are one degree away  so $\beta_i$
is 0.85 to dampen the component score. For Family as Faculty as an
Infrastructure, just over half of the participants represent marginalized identities
and communities, so $p_m$ is 0.75 and $\beta_i$ is set to 1.

```{r, echo = TRUE}
stst_intersectionally_marginalized_value <- 1
stst_intersectionally_marginalized_coefficient <- 1
tg_intersectionally_marginalized_value <- 0.95
tg_intersectionally_marginalized_coefficient <- 0.85
fafi_intersectionally_marginalized_value <- 0.75
fafi_intersectionally_marginalized_coefficient <- 1
```

### Calculate Participant Component Score

The Participant Component Score is calculated through the following equation:

$$
p_s = p_w \cdot p_n \cdot \left( 1 + \frac{(\beta_m \cdot p_m + \beta_i \cdot p_i)}{2} \right)
$$

```{r calculate-participant-score, echo = FALSE}
stst_marginalized_proportions_score <- adjust_component_score(
  stst_marginalized_proportions_value,
  stst_marginalized_proportions_coefficient
)

stst_intersectionally_marginalized_score <- adjust_component_score(
  stst_intersectionally_marginalized_value,
  stst_intersectionally_marginalized_coefficient
)

category_scores <- category_scores |>
  add_category(
    "STEM Studio",
    "Participation",
    stst_number_of_participants,
    participants_weight,
    stst_marginalized_proportions_score,
    stst_intersectionally_marginalized_score
  )

tg_marginalized_proportions_score <- adjust_component_score(
  tg_marginalized_proportions_value,
  tg_marginalized_proportions_coefficient
)

tg_intersectionally_marginalized_score <- adjust_component_score(
  tg_intersectionally_marginalized_value,
  tg_intersectionally_marginalized_coefficient
)

category_scores <- category_scores |>
  add_category(
    "PD @ TG",
    "Participation",
    tg_number_of_participants,
    1,
    tg_marginalized_proportions_score,
    tg_intersectionally_marginalized_score
  )

fafi_marginalized_proportions_score <- adjust_component_score(
  fafi_marginalized_proportions_value,
  fafi_marginalized_proportions_coefficient
)

fafi_intersectionally_marginalized_score <- adjust_component_score(
  fafi_intersectionally_marginalized_value,
  fafi_intersectionally_marginalized_coefficient
)

category_scores <- category_scores |>
  add_category(
    "FAFI",
    "Participation",
    fafi_number_of_participants,
    1,
    fafi_marginalized_proportions_score,
    fafi_intersectionally_marginalized_score
  )

# participation_component_list <- c("Number of Participants",
#                                   "Marginalized Participation Score",
#                                   "Intersectionally Marginalized Participation Score",
#                                   "Participation Category Index",
#                                   "Participation Category Score")
# rank_adjusted <- FALSE
#
# if(stst_marginalized_proportions_coefficient < 1) {
#   participation_component_list[2] <- "Marginalized Participation Score*"
#   rank_adjusted <- TRUE
# }
#
# if(stst_intersectionally_marginalized_value < 1) {
#   participation_component_list[3] <- "Intersectionally Marginalized Participation Score*"
#   rank_adjusted <- TRUE
# }

# participation_table <- category_scores |>
#  #select(-project_name) |>
#  create_display_table(
#    "Participation",
#    marginalized_proportions_value,
#    intersectionally_marginalized_value,
#    participation_component_list
#  )

# participation_table <- participation_table |>
#  gt()

# if(rank_adjusted == TRUE) {
#  participation_table <- participation_table |>
#      tab_footnote(footnote = "*Adjusted scores.")
# }

# participation_table
```

We find that the Professional Development Project has a Participant Index ($p_i$)
of `r (tg_marginalized_proportions_score + tg_intersectionally_marginalized_score) / 2`
(adjusted) and a full Participant Score ($p_s$) of `r round((1 + ((tg_marginalized_proportions_score + tg_intersectionally_marginalized_score) / 2)) * tg_number_of_participants, digits = 0)`.
Family as Faculty as an Infrastructure has a Participant Index ($p_i$) of
`r (fafi_marginalized_proportions_score + fafi_intersectionally_marginalized_score) / 2`
and a Participant Score ($p_s$) of `r round((1 + ((fafi_marginalized_proportions_score + fafi_intersectionally_marginalized_score) / 2)) * fafi_number_of_participants, digits = 0)`.

## Engagement

Number of contact hours $e_h$.

```{r engagement-weight, echo=TRUE}
engagement_weight <- 1
```

```{r engagement-frame, echo=FALSE}
engagement_frame <- data.frame(
  frequency = c(
    "Once",
    "Once Per Year",
    "Several Times Per Year",
    "Every Other Month",
    "Once Per Month",
    "Every Other Week",
    "Once Per Week",
    "2-4 Times Per Week",
    "5 Times Per Week",
    "Daily"
  ),
  duration = c(
    "One Day",
    "Less Than A Week",
    "One Week",
    "2-3 Weeks",
    "One Month",
    "One Semester",
    "One Year",
    "2-3 Years",
    "3-10 Years",
    "10+ Years"
  ),
  value = c(
    0.1,
    0.25,
    0.33,
    0.4,
    0.5,
    0.75,
    0.85,
    0.9,
    0.95,
    1
  )
)

engagement_frame |>
  gt()
```

### Engagement Hours

```{r, echo = TRUE}
stst_engagement_hours <- 16
tg_engagement_hours <- 18
fafi_engagement_hours <- 20
```

### Frequency

```{r frequency-score, echo = TRUE}
stst_frequency_score <- 0.85
tg_frequency_score <- 0.50
fafi_frequency_score <- 0.75
```
  
### Duration

```{r duration-score, echo = TRUE}
stst_duration_score <- 0.75
tg_duration_score <- 0.85
fafi_duration_score <- 0.75
```

### Calculate Engagement Score

$$
e_s = e_w \cdot e_h \cdot \left(1 + \frac{(e_d + e_f)}{2}\right)
$$

```{r calculate-engagement-score}
category_scores <- category_scores |>
  add_category(
    "STEM Studio",
    "Engagement",
    stst_engagement_hours,
    engagement_weight,
    stst_frequency_score,
    stst_duration_score
  )

category_scores <- category_scores |>
  add_category(
    "PD @ TG",
    "Engagement",
    tg_engagement_hours,
    engagement_weight,
    tg_frequency_score,
    tg_duration_score
  )

category_scores <- category_scores |>
  add_category(
    "FAFI",
    "Engagement",
    fafi_engagement_hours,
    engagement_weight,
    fafi_frequency_score,
    fafi_duration_score
  )

# engagement_component_list <- c("Number of Contact Hours",
#                                   "Frequency Component Score",
#                                   "Duration Component Score",
#                                   "Engagement Category Index",
#                                   "Engagement Category Score")
#
# engagement_table <- category_scores |>
#  select(-project_name) |>
#  create_display_table(
#    "Engagement",
#    frequency_score,
#    duration_score,
#    engagement_component_list
#  )

# engagement_table |>
#  gt()
```

## Infrastructure Score

```{r infrastructure-weight, echo=TRUE}
infrastructure_weight <- 1.5
```

```{r infrastructure-frame, echo=FALSE}
infrastructure_frame <- data.frame(
  purpose = c(
    "Promoting Efficiency Only",
    "Promoting Predominantly Efficiency And Recognizing Plurality and Multivocality",
    "Promoting Mostly Efficiency And Recognizing Plurality and Multivocality",
    "Promoting Mostly Efficiency And Recognizing Plurality, Multivocality, and Honor",
    "Promoting Efficiency, Plurality, Multivocality, and Honor Equitably"
  ),
  co_construction = c(
    "Initiation and Construction From One Party",
    "Initiation and Construction From One Party With Feedback By Another",
    "Initiation From One Party and Construction By Another",
    "Initiated and Constructed Mostly Equitably",
    "Initiated and Constructed Equitably"
  ),
  value = c(
    0.1,
    0.5,
    0.9,
    0.95,
    1
  )
)

infrastructure_frame |>
  gt()
```

### Number of Intrastructure/Intermediate Products

```{r infrastructure-products, echo = TRUE}
stst_number_of_infrastructure_products <- 8
tg_number_of_infrastructure_products <- 10
fafi_number_of_infrastructure_products <- 12
```

### Infrastructure Purpose
```{r, echo = TRUE}
stst_infrastructure_purpose <- 0.90
tg_infrastructure_purpose <- 0.90
fafi_infrastructure_purpose <- 0.95
```

### Infrastructure Co-Construction
```{r, echo = TRUE}
stst_infrastructure_co_construction <- 0.10
tg_infrastructure_co_construction <- 0.10
fafi_infrastructure_co_construction <- 0.50
```

### Calculate Infrastructure Score

$$
i_s = i_p \left(1 + \frac{(i_u + i_c)}{2}\right)
$$

```{r calculate-infrastructure-score}
category_scores <- category_scores |>
  add_category(
    "STEM Studio",
    "Infrastructure",
    stst_number_of_infrastructure_products,
    infrastructure_weight,
    stst_infrastructure_purpose,
    stst_infrastructure_co_construction
  )

category_scores <- category_scores |>
  add_category(
    "PD @ TG",
    "Infrastructure",
    tg_number_of_infrastructure_products,
    infrastructure_weight,
    tg_infrastructure_purpose,
    tg_infrastructure_co_construction
  )

category_scores <- category_scores |>
  add_category(
    "FAFI",
    "Infrastructure",
    fafi_number_of_infrastructure_products,
    infrastructure_weight,
    fafi_infrastructure_purpose,
    fafi_infrastructure_co_construction
  )

# infrastructure_component_list <- c("Number of Infrasctructure Products",
#                                   "Infrastructure Purpose Score",
#                                   "Infrastructure Co-Construction Score",
#                                   "Infrastructure Category Index",
#                                   "Infrastructure Category Score")
#
# infrastructure_table <- category_scores |>
#  select(-project_name) |>
#  create_display_table(
#    "Infrastructure",
#    infrastructure_purpose,
#    infrastructure_co_construction,
#    infrastructure_component_list
#  )

# infrastructure_table |>
#  gt()
```

## Outputs Score

```{r outputs-weight, echo=TRUE}
outputs_weight <- 1.5
```

```{r outputs-frame, echo=FALSE}
outputs_frame <- data.frame(
  venues = c(
    "Only One Type of Venue",
    "Predominantly One Type of Venue",
    "Mostly One Type of Venue",
    "Almost Even Mix of Venues",
    "Even Mix of Venues"
  ),
  inclusion = c(
    "No Inclusion",
    "Member Check Opportunities",
    "Inclusion in Writing",
    "Inclusion in Data Curation, Analysis, and Writing",
    "Full Partnership"
  ),
  value = c(
    0.10,
    0.50,
    0.90,
    0.95,
    1
  )
)

outputs_frame |>
  gt()
```

### Number of Outputs Products

```{r number-outputs, echo = TRUE}
stst_number_of_outputs <- 1
tg_number_of_outputs <- 0
fafi_number_of_outputs <- 6
```

### Distribution of Venues

```{r venue-distribution, echo = TRUE}
stst_distribution_of_venues <- 0.10
tg_distribution_of_venues <- 0.10
fafi_distribution_of_venues <- 0.90
```

### Inclusion of Participants and Partners

```{r participant-inclusion, echo = TRUE}
stst_inclusion_of_participants <- 0.90
tg_inclusion_of_participants <- 0.10
fafi_inclusion_of_participants <- 0.50
```

### Calculate Outputs Score

$$
o_s = o_p \left(1 + \frac{(o_v + o_i)}{2}\right)
$$

```{r calculate-outputs-score}
category_scores <- category_scores |>
  add_category(
    "STEM Studio",
    "Outputs",
    stst_number_of_outputs,
    outputs_weight,
    stst_distribution_of_venues,
    stst_inclusion_of_participants
  )

category_scores <- category_scores |>
  add_category(
    "PD @ TG",
    "Outputs",
    tg_number_of_outputs,
    outputs_weight,
    tg_distribution_of_venues,
    tg_inclusion_of_participants
  )

category_scores <- category_scores |>
  add_category(
    "FAFI",
    "Outputs",
    fafi_number_of_outputs,
    outputs_weight,
    fafi_distribution_of_venues,
    fafi_inclusion_of_participants
  )
#
# outputs_component_list <- c("Number of Output Products",
#                                   "Distribution of Venues Score",
#                                   "Inclusion of Participants Score",
#                                   "Outputs Category Index",
#                                   "Outputs Category Score")
#
# outputs_table <- category_scores |>
#  select(-project_name) |>
#  create_display_table(
#    "Outputs",
#    distribution_of_venues,
#    inclusion_of_participants,
#    outputs_component_list
#  )

# outputs_table |>
#  gt()
```

## Sustainability

```{r sustainability-weight, echo=TRUE}
sustainability_weight <- 2
```

```{r sustainability-frame, echo=FALSE}
sustainability_frame <- data.frame(
  responsibility = c(
    "Responsibility Distributed to One Partner",
    "Responsibility Predominantly Distributed to One Partner",
    "Responsibility Mostly Distributed to One or More Partners",
    "Almost Equitable Distribution of Responsibility Across Partners",
    "Equitable Distribution of Responsibility Across Partners"
  ),
  material = c(
    "No Material Support",
    "Material Support Predominantly Through One Partner",
    "Material Support Mostly Through One or More Partners",
    "Material Support Almost Equitably Distributed Across Partners",
    "Equitable Material Support Across Partners"
  ),
  value = c(
    0.1,
    0.5,
    0.9,
    0.95,
    1
  )
)

sustainability_frame |>
  gt()
```

### Number of Institutional Partners

```{r partner-number, echo = TRUE}
stst_number_of_partners <- 2
tg_number_of_partners <- 1
fafi_number_of_partners <- 4
```

### Distribution of Responsibility

```{r responsibility-distribution, echo = TRUE}
stst_distribution_of_responsibility <- 0.5
tg_distribution_of_responsibility <- 0.5
fafi_distribution_of_responsibility <- 0.9
```

### Distribution of Material Support

```{r material-support, echo = TRUE}
stst_distribution_of_material_support <- 0.5
tg_distribution_of_material_support <- 0.5
fafi_distribution_of_material_support <- 0.5
```

### Calculate Sustainability Score

$$
s_s = s_p \left(1 + \frac{(s_r + s_m)}{2}\right)
$$

```{r calculate-sustainability-score}
category_scores <- category_scores |>
  add_category(
    "STEM Studio",
    "Sustainability",
    stst_number_of_partners,
    sustainability_weight,
    stst_distribution_of_responsibility,
    stst_distribution_of_material_support
  )

category_scores <- category_scores |>
  add_category(
    "PD @ TG",
    "Sustainability",
    tg_number_of_partners,
    sustainability_weight,
    tg_distribution_of_responsibility,
    tg_distribution_of_material_support
  )

category_scores <- category_scores |>
  add_category(
    "FAFI",
    "Sustainability",
    fafi_number_of_partners,
    sustainability_weight,
    fafi_distribution_of_responsibility,
    fafi_distribution_of_material_support
  )
#
# sustainability_component_list <- c("Number of Partners",
#                                   "Distribution of Responsibiilty Score",
#                                   "Distribution of Material Support Score",
#                                   "Sustainability Category Index",
#                                   "Sustainability Category Score")
#
# sustainability_table <- category_scores |>
#  select(-project_name) |>
#  create_display_table(
#    "Sustainability",
#    distribution_of_responsibility,
#    distribution_of_material_support,
#    sustainability_component_list
#  )

# sustainability_table |>
#  gt()
```

## Ripple Effects

One of the trickier elements to measure in community-engaged research are "ripple
effects." Because we are working in direct contact and cooperation with publics,
we can assume that the work we do together has a broader impact than just the time
we spend together. [Ripple effects mapping](https://extension.umn.edu/community-development/ripple-effect-mapping) is
an excellent qualitative tool for capturing and understanding the ways in which
participants' views and practices change through the cooperative work. It is,
however, very difficult to distill into a quantitative metric.

For the purposes of these metrics, we use *the number of people potentially impacted*
as a way to measure these ripple effects over a number of degrees of separation from
the participants directly impacted.

It is understood that with each degree of separation, there is going to be a lessening
of impact; the equation used to calcuate the `Ripple Effect` ($\eta_r$) at each
degree ($d_r$) includes both a `decay constant` ($\lambda_r$), which is set to
**0.55**, and utilizes an inverse logarithmic function to calculate a reduction of
impact over each degree.

$$
\eta_r =  \lambda_r \cdot \frac{n_r}{\log(d_r + 1)}
$$

In this equation, $n_r$ represents the number of people potentially impacted by
the community engaged work. This is divided by the logarithm of the degree of
separation ($d_r$)[The $\log$ of $d_r + 1$ is calculated to avoid 0 in the denominator]{.aside}
and then multiplied by the decay constant ($\lambda_r$), providing a ripple effect score
($\eta_r$) at each degree of separation.

### Teacher Professional Development

For the Professional Development project, impact at each degree is determined this way:

* *Direct Impact:* **70 teachers** participated in the Professional Development
project.
* *1 Degree of Separation:* There are **522 students** enrolled in the school,
resulting in the likelihood that there will be some impact from the
Professional Development.
* *2 Degrees of Separation:* The [average family size in Indianapolis](https://en.wikipedia.org/wiki/Indianapolis_(balance)) is 3.04 people.
The potential family size, however, is assumed to be rounded *up* to 4 people in a family.
This allows for "non-traditional," non-normative, and more expansive family structures
to be counted. This translates to potentially around **2,088 family members**.

```{r set-pdtg-ripple, echo = TRUE}
pdtg_ripple <- data.frame(
  group = c(0, 1, 2),
  group_name = c(
    "Teachers",
    "Students",
    "Family Members"
  ),
  values = c(70, 522, 2088)
)
```

### Family as Faculty as an Infrastructure

The Family as Faculty as an Infrastructure is a much more complex project, even
though it may directly involve fewer people. As delineated in the
[Participants section](#number-of-participants), there are a number of
different categories of participants. Impact is also mapped out to a further degree
given that it involves Teacher Education Students, so their future K-12 students
need to be considered. Impact at each degree is determined in the following manner:

* *Direct Impact:* There are **50 participants** directly involved in the project
as outlined in the [Participants section](#number-of-participants).
* *1 Degree of Separation:* The complexity of the project is clearly evident at
this degree, as there are different connections that can be considered. Because
the Teacher Education Students are involved in the school, we include the 388 students
in the school. In addition, we include four family members for each Family Leader
and Neighborhood Caucus Member, for a total of 36. We also assume approximately
100 members of Down Syndrome Indiana who may be reached at this degree. This results
in potentially **524 people** being impacted.
* *2 Degrees of Separation:* According to a survey of the Teacher Education Students,
80%, or 24 students, indicated that they were going to be continuing on the path
to becoming a teacher. We can assume that each of these future teachers will have
an average of [26.9 K-12 students](https://nces.ed.gov/surveys/ntps/tables/ntps1718_fltable06_t1s.asp)
in their classes in Indiana. This translates to a potential of **648 K-12 students**
*per year.*
* *3 Degrees of Separation:* Because this is a project that links and empowers families
and educators to best support the learning of K-12 students, the last degree of separation
involves the potential families of the future K-12 students. Four family members for
648 students potentially results in **2592 family members** *per year.*

```{r set-fafi-ripple, echo = TRUE}
fafi_ripple <- data.frame(
  group = c(0, 1, 2, 3),
  group_name = c(
    "Participants",
    "Contemporaries",
    "Future Students",
    "Future Families"
  ),
  values = c(50, 524, 648, 2592)
)
```

### STEM Studio

```{r set-stst-ripple, echo = TRUE}
stst_ripple <- data.frame(
  group = c(0, 1, 2),
  group_name = c(
    "Participants",
    "Family Members",
    "Friends"
  ),
  values = c(7, 28, 35)
)
```

### Calculate and Visualize Ripple Effects

```{r calculate-plot-ripple}
pdtg_ripple <- pdtg_ripple |> calculate_ripple()
fafi_ripple <- fafi_ripple |> calculate_ripple()
stst_ripple <- stst_ripple |> calculate_ripple()

pdtg_vogel_frame <- pdtg_ripple |> prepare_vogel()
fafi_vogel_frame <- fafi_ripple |> prepare_vogel()
stst_vogel_frame <- stst_ripple |> prepare_vogel()

pdtg_vogel_ripple <- pdtg_vogel_frame |> plot_vogel(pdtg_ripple$group_name)
fafi_vogel_ripple <- fafi_vogel_frame |> plot_vogel(fafi_ripple$group_name)
stst_vogel_ripple <- stst_vogel_frame |> plot_vogel(stst_ripple$group_name)

pdtg_composite_ripple_score <- sum(pdtg_ripple$ripple_score)
fafi_composite_ripple_score <- sum(fafi_ripple$ripple_score)
stst_composite_ripple_score <- sum(stst_ripple$ripple_score)
```

The Professional Development project has a Ripple Effect Score of **`r pdtg_composite_ripple_score`**.
The ripple effect plot, based on a Vogel Spiral, looks like this:

```{r}
print(pdtg_vogel_ripple)
```

The Family as Faculty as an Infrastructure project has a Ripple Effect Score of
**`r fafi_composite_ripple_score`**. The ripple effect plot looks like this:

```{r}
print(fafi_vogel_ripple)
```

The STEM Studio project has a Ripple Effect Score of
**`r stst_composite_ripple_score`**. The ripple effect plot looks like this:

```{r}
print(stst_vogel_ripple)
```


::: {.callout-important}
## Remember that The Map is Not the Territory

This is a model, and while it is robust, it is still an estimation of the ripple
effects of community-engaged research projects. It is important to provide accurate
and well-reasoned numbers in the model, and it is important to capture different
types of evidence to support a deep understanding of the impacts of this type of
research.
:::

## Composite Impact Score

$$
S_O = \sum_{x=1}^n s_x
$$

```{r}
stst_overall_score <- calculate_overall(category_scores, "STEM Studio")
pdtg_overall_score <- calculate_overall(category_scores, "PD @ TG")
fafi_overall_score <- calculate_overall(category_scores, "FAFI")
```

The Overall Score $S_O$ for the STEM Studio is **`r stst_overall_score`**, the
Overall Score $S_O$ for the Professional Development is **`r pdtg_overall_score`**, and
the Overall Score $S_O$ for Family as Faculty as an Infrastructure is **`r fafi_overall_score`**.

## Overall Representation

> "Red Beans and Ricely Yours"
>
> -- Louis Armstrong

!["Here are my beans, come count them!" As imagined by Adobe Firefly.](assets/introbeans.jpg)

```{r represent, fig.showtext=TRUE, warning=FALSE, message=FALSE, echo=FALSE}
category_names <- c(
  "Sustainability",
  "Outputs",
  "Infrastructure",
  "Engagement",
  "Participation"
)

pdtg_composite_frame <- category_scores |>
  prep_composite("PD @ TG")
fafi_composite_frame <- category_scores |>
  prep_composite("FAFI")
stst_composite_frame <- category_scores |>
  prep_composite("STEM Studio")

pdtg_arch_frame <- pdtg_composite_frame |>
  prep_arch()
fafi_arch_frame <- fafi_composite_frame |>
  prep_arch()
stst_arch_frame <- stst_composite_frame |>
  prep_arch()

pdtg_composite_arch <- pdtg_arch_frame |>
  plot_arch(pdtg_composite_frame)
fafi_composite_arch <- fafi_arch_frame |>
  plot_arch(fafi_composite_frame)
stst_composite_arch <- stst_arch_frame |>
  plot_arch(stst_composite_frame)

pdtg_arch_title <- create_title_line("Composite Impact Score", pdtg_overall_score)
fafi_arch_title <- create_title_line("Composite Impact Score", fafi_overall_score)
stst_arch_title <- create_title_line("Composite Impact Score", stst_overall_score)

pdtg_ripple_title <- create_title_line("Ripple Effect Score", pdtg_composite_ripple_score)
fafi_ripple_title <- create_title_line("Ripple Effect Score", fafi_composite_ripple_score)
stst_ripple_title <- create_title_line("Ripple Effect Score", stst_composite_ripple_score)

indicator_weights <- data.frame(
  weights = c(
    participants_weight,
    engagement_weight,
    infrastructure_weight,
    outputs_weight,
    sustainability_weight
  )
)

pdtg_composite_indicator_score <- calculate_indicator_score(
  category_scores,
  "PD @ TG",
  indicator_weights
)
fafi_composite_indicator_score <- calculate_indicator_score(
  category_scores,
  "FAFI",
  indicator_weights
)
stst_composite_indicator_score <- calculate_indicator_score(
  category_scores,
  "STEM Studio",
  indicator_weights
)

pdtg_indicator_title <- create_title_line("Direct Indicator Score", pdtg_composite_indicator_score)
fafi_indicator_title <- create_title_line("Direct Indicator Score", fafi_composite_indicator_score)
stst_indicator_title <- create_title_line("Direct Indicator Score", stst_composite_indicator_score)

pdtg_bottom_badge <- construct_bottom_badge(
  pdtg_arch_title,
  pdtg_ripple_title,
  pdtg_composite_arch,
  pdtg_vogel_ripple
)
fafi_bottom_badge <- construct_bottom_badge(
  fafi_arch_title,
  fafi_ripple_title,
  fafi_composite_arch,
  fafi_vogel_ripple
)
stst_bottom_badge <- construct_bottom_badge(
  stst_arch_title,
  stst_ripple_title,
  stst_composite_arch,
  stst_vogel_ripple
)

pdtg_indicator_frame <- prep_indicators(category_scores, "PD @ TG")
fafi_indicator_frame <- prep_indicators(category_scores, "FAFI")
stst_indicator_frame <- prep_indicators(category_scores, "STEM Studio")

pdtg_indicator_plot <- plot_indicators(pdtg_indicator_frame)
fafi_indicator_plot <- plot_indicators(fafi_indicator_frame)
stst_indicator_plot <- plot_indicators(stst_indicator_frame)

pdtg_badge <- construct_badge(
  pdtg_indicator_title,
  pdtg_indicator_plot,
  pdtg_bottom_badge
)

fafi_badge <- construct_badge(
  fafi_indicator_title,
  fafi_indicator_plot,
  fafi_bottom_badge
)

stst_badge <- construct_badge(
  stst_indicator_title,
  stst_indicator_plot,
  stst_bottom_badge
)

ggsave("outputs/pdtg_badge.png", pdtg_badge, width = 16, height = 10, units = "in", dpi = 320)
ggsave("outputs/pdtg_badge.pdf", pdtg_badge, width = 16, height = 10, units = "in", dpi = 320)
ggsave("outputs/fafi_badge.png", fafi_badge, width = 16, height = 10, units = "in", dpi = 320)
ggsave("outputs/fafi_badge.pdf", fafi_badge, width = 16, height = 10, units = "in", dpi = 320)
ggsave("outputs/stst_badge.png", stst_badge, width = 16, height = 10, units = "in", dpi = 320)
ggsave("outputs/stst_badge.pdf", stst_badge, width = 16, height = 10, units = "in", dpi = 320)
```

### Professional Development Example

An example of a detailed badge for a professional development program at a school. This badge contains multiple levels of information including the overall score, the ripple effect score, and direct indicators.

:::{.column-page-inset}
![](outputs/pdtg_badge.png)
:::

### Family as Faculty as Infrastructure Example

:::{.column-page-inset}
![](outputs/fafi_badge.png)
:::

### STEM Studio Example

:::{.column-page-inset}
![](outputs/stst_badge.png)
:::
